diff --git a/android/src/debug/java/com/facebook/react/devsupport/BundleDownloader.java b/android/src/debug/java/com/facebook/react/devsupport/BundleDownloader.java
new file mode 100644
index 0000000000000000000000000000000000000000..8fb8c35525b20e9c910f35673d1aaaa28ff24aa3
--- /dev/null
+++ b/android/src/debug/java/com/facebook/react/devsupport/BundleDownloader.java
@@ -0,0 +1,285 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+package com.facebook.react.devsupport;
+
+import androidx.annotation.Nullable;
+import com.facebook.common.logging.FLog;
+import com.facebook.infer.annotation.Assertions;
+import com.facebook.react.common.DebugServerException;
+import com.facebook.react.common.ReactConstants;
+import com.facebook.react.devsupport.interfaces.DevBundleDownloadListener;
+import java.io.File;
+import java.io.IOException;
+import java.util.Map;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import okhttp3.Call;
+import okhttp3.Callback;
+import okhttp3.Headers;
+import okhttp3.OkHttpClient;
+import okhttp3.Request;
+import okhttp3.Response;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.Okio;
+import okio.Sink;
+import org.json.JSONException;
+import org.json.JSONObject;
+
+public class BundleDownloader {
+  private static final String TAG = "BundleDownloader";
+
+  // Should be kept in sync with constants in RCTJavaScriptLoader.h
+  private static final int FILES_CHANGED_COUNT_NOT_BUILT_BY_BUNDLER = -2;
+
+  private final OkHttpClient mClient;
+
+  private @Nullable Call mDownloadBundleFromURLCall;
+
+  public static class BundleInfo {
+    private @Nullable String mUrl;
+    private int mFilesChangedCount;
+
+    public static @Nullable BundleInfo fromJSONString(String jsonStr) {
+      if (jsonStr == null) {
+        return null;
+      }
+
+      BundleInfo info = new BundleInfo();
+
+      try {
+        JSONObject obj = new JSONObject(jsonStr);
+        info.mUrl = obj.getString("url");
+        info.mFilesChangedCount = obj.getInt("filesChangedCount");
+      } catch (JSONException e) {
+        FLog.e(TAG, "Invalid bundle info: ", e);
+        return null;
+      }
+
+      return info;
+    }
+
+    public @Nullable String toJSONString() {
+      JSONObject obj = new JSONObject();
+
+      try {
+        obj.put("url", mUrl);
+        obj.put("filesChangedCount", mFilesChangedCount);
+      } catch (JSONException e) {
+        FLog.e(TAG, "Can't serialize bundle info: ", e);
+        return null;
+      }
+
+      return obj.toString();
+    }
+
+    public String getUrl() {
+      return mUrl != null ? mUrl : "unknown";
+    }
+
+    public int getFilesChangedCount() {
+      return mFilesChangedCount;
+    }
+  }
+
+  public BundleDownloader(OkHttpClient client) {
+    mClient = client;
+  }
+
+  public void downloadBundleFromURL(
+      final DevBundleDownloadListener callback,
+      final File outputFile,
+      final String bundleURL,
+      final @Nullable BundleInfo bundleInfo) {
+    downloadBundleFromURL(callback, outputFile, bundleURL, bundleInfo, new Request.Builder());
+  }
+
+  public void downloadBundleFromURL(
+      final DevBundleDownloadListener callback,
+      final File outputFile,
+      final String bundleURL,
+      final @Nullable BundleInfo bundleInfo,
+      Request.Builder requestBuilder) {
+
+    final Request request =
+        requestBuilder.url(bundleURL).addHeader("Accept", "multipart/mixed").build();
+    mDownloadBundleFromURLCall = Assertions.assertNotNull(mClient.newCall(request));
+    mDownloadBundleFromURLCall.enqueue(
+        new Callback() {
+          @Override
+          public void onFailure(Call call, IOException e) {
+            // ignore callback if call was cancelled
+            if (mDownloadBundleFromURLCall == null || mDownloadBundleFromURLCall.isCanceled()) {
+              mDownloadBundleFromURLCall = null;
+              return;
+            }
+            mDownloadBundleFromURLCall = null;
+
+            String url = call.request().url().toString();
+
+            callback.onFailure(
+                DebugServerException.makeGeneric(
+                    url, "Could not connect to development server.", "URL: " + url, e));
+          }
+
+          @Override
+          public void onResponse(Call call, final Response response) throws IOException {
+            // ignore callback if call was cancelled
+            if (mDownloadBundleFromURLCall == null || mDownloadBundleFromURLCall.isCanceled()) {
+              mDownloadBundleFromURLCall = null;
+              return;
+            }
+            mDownloadBundleFromURLCall = null;
+
+            final String url = response.request().url().toString();
+
+            // Make sure the result is a multipart response and parse the boundary.
+            String contentType = response.header("content-type");
+            Pattern regex = Pattern.compile("multipart/mixed;.*boundary=\"([^\"]+)\"");
+            Matcher match = regex.matcher(contentType);
+            try (Response r = response) {
+              if (match.find()) {
+                processMultipartResponse(url, r, match.group(1), outputFile, bundleInfo, callback);
+              } else {
+                // In case the server doesn't support multipart/mixed responses, fallback to normal
+                // download.
+                processBundleResult(
+                    url,
+                    r.code(),
+                    r.headers(),
+                    Okio.buffer(r.body().source()),
+                    outputFile,
+                    bundleInfo,
+                    callback);
+              }
+            }
+          }
+        });
+  }
+
+  private void processMultipartResponse(
+      final String url,
+      final Response response,
+      String boundary,
+      final File outputFile,
+      @Nullable final BundleInfo bundleInfo,
+      final DevBundleDownloadListener callback)
+      throws IOException {
+
+    MultipartStreamReader bodyReader =
+        new MultipartStreamReader(response.body().source(), boundary);
+    boolean completed =
+        bodyReader.readAllParts(
+            new MultipartStreamReader.ChunkListener() {
+              @Override
+              public void onChunkComplete(Map<String, String> headers, BufferedSource body, boolean isLastChunk)
+                  throws IOException {
+                if (isLastChunk || "application/javascript".equals(headers.get("Content-Type"))) {
+                  int status = response.code();
+                  if (headers.containsKey("X-Http-Status")) {
+                    status = Integer.parseInt(headers.get("X-Http-Status"));
+                  }
+                  processBundleResult(
+                      url, status, Headers.of(headers), body, outputFile, bundleInfo, callback);
+                } else if ("application/json".equals(headers.get("Content-Type"))) {
+                  try {
+                    String progressText = body.readUtf8(); // safe because progress is small
+                    JSONObject progress = new JSONObject(progressText);
+                    String status = progress.optString("status", "Bundling");
+                    Integer done = progress.has("done") ? progress.getInt("done") : null;
+                    Integer total = progress.has("total") ? progress.getInt("total") : null;
+                    callback.onProgress(status, done, total);
+                  } catch (JSONException e) {
+                    FLog.e(ReactConstants.TAG, "Error parsing progress JSON: " + e);
+                  }
+                }
+              }
+
+              @Override
+              public void onChunkProgress(Map<String, String> headers, long loaded, long total) {
+                if ("application/javascript".equals(headers.get("Content-Type"))) {
+                  callback.onProgress("Downloading", (int) (loaded / 1024), (int) (total / 1024));
+                }
+              }
+            });
+    if (!completed) {
+      callback.onFailure(
+          new DebugServerException(
+              "Error while reading multipart response.\n\nResponse code: "
+                  + response.code()
+                  + "\n\n"
+                  + "URL: "
+                  + url.toString()
+                  + "\n\n"));
+    }
+  }
+
+  private void processBundleResult(
+    String url,
+    int statusCode,
+    Headers headers,
+    BufferedSource body,
+    File outputFile,
+    BundleInfo bundleInfo,
+    DevBundleDownloadListener callback
+) throws IOException {
+  if (statusCode != 200) {
+    String errorText = body.readUtf8(); // read small error body into memory
+    DebugServerException exception = DebugServerException.parse(url, errorText);
+    if (exception != null) {
+      callback.onFailure(exception);
+    } else {
+      callback.onFailure(new DebugServerException("Server error: " + errorText));
+    }
+    return;
+  }
+
+  if (bundleInfo != null) {
+    populateBundleInfo(url, headers, bundleInfo);
+  }
+
+  File tmpFile = new File(outputFile.getPath() + ".tmp");
+  try (Sink output = Okio.sink(tmpFile)) {
+    body.readAll(output); // stream to disk
+  }
+
+  if (!tmpFile.renameTo(outputFile)) {
+    throw new IOException("Failed to move temp file to final location");
+  }
+
+  callback.onSuccess();
+}
+
+  private static boolean storePlainJSInFile(BufferedSource body, File outputFile)
+      throws IOException {
+    Sink output = null;
+    try {
+      output = Okio.sink(outputFile);
+      body.readAll(output);
+    } finally {
+      if (output != null) {
+        output.close();
+      }
+    }
+
+    return true;
+  }
+
+  private static void populateBundleInfo(String url, Headers headers, BundleInfo bundleInfo) {
+    bundleInfo.mUrl = url;
+
+    String filesChangedCountStr = headers.get("X-Metro-Files-Changed-Count");
+    if (filesChangedCountStr != null) {
+      try {
+        bundleInfo.mFilesChangedCount = Integer.parseInt(filesChangedCountStr);
+      } catch (NumberFormatException e) {
+        bundleInfo.mFilesChangedCount = FILES_CHANGED_COUNT_NOT_BUILT_BY_BUNDLER;
+      }
+    }
+  }
+}
diff --git a/android/src/debug/java/com/facebook/react/devsupport/MultipartStreamReader.java b/android/src/debug/java/com/facebook/react/devsupport/MultipartStreamReader.java
new file mode 100644
index 0000000000000000000000000000000000000000..fe6d2ceed86dd7d394afde24f4f86d88a75e9ae6
--- /dev/null
+++ b/android/src/debug/java/com/facebook/react/devsupport/MultipartStreamReader.java
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) Meta Platforms, Inc. and affiliates.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+
+package com.facebook.react.devsupport;
+
+import java.io.EOFException;
+import java.io.IOException;
+import java.util.HashMap;
+import java.util.Map;
+import okio.Buffer;
+import okio.BufferedSource;
+import okio.ByteString;
+
+/** Utility class to parse the body of a response of type multipart/mixed. */
+public class MultipartStreamReader {
+
+  private static final String CRLF = "\r\n";
+  private final BufferedSource source;
+  private final String boundary;
+
+  public interface ChunkListener {
+    void onChunkComplete(Map<String, String> headers, BufferedSource body, boolean isLastChunk) throws IOException;
+    void onChunkProgress(Map<String, String> headers, long loaded, long total) throws IOException;
+  }
+
+  public MultipartStreamReader(BufferedSource source, String boundary) {
+    this.source = source;
+    this.boundary = boundary;
+  }
+
+  public boolean readAllParts(final ChunkListener listener) throws IOException {
+    final String boundaryMarker = "--" + boundary;
+    final String closingMarker = boundaryMarker + "--";
+
+    int partCount = 0;
+    Map<String, String> headers = null;
+    Buffer chunkBuffer = null;
+
+    while (!source.exhausted()) {
+      String line;
+      try {
+        line = source.readUtf8LineStrict();
+      } catch (EOFException eof) {
+        // emit last part if boundary was missing
+        if (headers != null && chunkBuffer != null) {
+          listener.onChunkComplete(headers, chunkBuffer, true);
+        }
+        return true;
+      }
+
+      if (line == null || !line.startsWith("--")) continue;
+      if (!line.equals(boundaryMarker) && !line.equals(closingMarker)) continue;
+
+      // âœ… Emit previous part before starting a new one
+      if (headers != null && chunkBuffer != null) {
+        boolean isLast = line.equals(closingMarker);
+        listener.onChunkComplete(headers, chunkBuffer, isLast);
+        headers = null;
+        chunkBuffer = null;
+        partCount++;
+      }
+
+      if (line.equals(closingMarker)) {
+        return true;
+      }
+
+      headers = new HashMap<>();
+      while (true) {
+        String headerLine = source.readUtf8LineStrict();
+        if (headerLine.isEmpty()) break;
+        int index = headerLine.indexOf(':');
+        if (index != -1) {
+          headers.put(headerLine.substring(0, index).trim(), headerLine.substring(index + 1).trim());
+        }
+      }
+
+      chunkBuffer = new Buffer();
+      while (!source.exhausted()) {
+        source.request(1);
+        String maybeBoundary;
+        try {
+          maybeBoundary = source.readUtf8LineStrict();
+        } catch (EOFException eof) {
+          listener.onChunkComplete(headers, chunkBuffer, true);
+          return true;
+        }
+
+        if (maybeBoundary.equals(boundaryMarker) || maybeBoundary.equals(closingMarker)) {
+          // boundary found: backtrack to outer loop to emit and re-parse
+          source.buffer().writeUtf8(maybeBoundary).writeUtf8("\n");
+          break;
+        }
+
+        chunkBuffer.writeUtf8(maybeBoundary).writeUtf8("\n");
+      }
+    }
+
+    // last fallback
+    if (headers != null && chunkBuffer != null) {
+      listener.onChunkComplete(headers, chunkBuffer, true);
+    }
+
+    return true;
+  }
+}
diff --git a/android/src/debug/java/expo/modules/devlauncher/helpers/DevLauncherReactUtils.kt b/android/src/debug/java/expo/modules/devlauncher/helpers/DevLauncherReactUtils.kt
index 72fd91c1795b33e1ebde65754878f3491f9954dd..8a8e7ece50809d1bd31149d3fb5b31a2463db5ff 100644
--- a/android/src/debug/java/expo/modules/devlauncher/helpers/DevLauncherReactUtils.kt
+++ b/android/src/debug/java/expo/modules/devlauncher/helpers/DevLauncherReactUtils.kt
@@ -14,6 +14,7 @@ import com.facebook.react.devsupport.DevLauncherSettings
 import com.facebook.react.devsupport.DevServerHelper
 import com.facebook.react.devsupport.DevSupportManagerBase
 import com.facebook.react.devsupport.interfaces.DevSupportManager
+import com.facebook.react.devsupport.BundleDownloader
 import com.facebook.react.modules.systeminfo.AndroidInfoHelpers
 import com.facebook.react.runtime.ReactHostDelegate
 import com.facebook.react.runtime.ReactHostImpl
@@ -25,6 +26,7 @@ import expo.modules.devlauncher.react.DevLauncherDevSupportManagerSwapper
 import expo.modules.devmenu.DevMenuManager
 import expo.modules.devmenu.helpers.setPrivateDeclaredFieldValue
 import okhttp3.HttpUrl
+import okhttp3.OkHttpClient;
 
 // Sync this class name with ExpoReactHostFactory.kt
 private const val EXPO_REACT_HOST_DELEGATE_CLASS = "expo.modules.ExpoReactHostFactory.ExpoReactHostDelegate"
@@ -138,6 +140,23 @@ private fun injectDebugServerHost(
   val packagerConnectionSettingsField = DevServerHelper::class.java.getDeclaredField("mPackagerConnectionSettings")
   packagerConnectionSettingsField.isAccessible = true
   packagerConnectionSettingsField[devServerHelper] = settings.public_getPackagerConnectionSettings()
+
+  /*
+   * @andrei.calazans: We are injecting a custom BundleDownloader to fix a OOM
+   * issue when loading very large bundles.
+   * */
+  val mBundleDownloaderField = DevServerHelper::class.java.getDeclaredField("mBundleDownloader")
+  mBundleDownloaderField.isAccessible = true
+
+  // Retrieve the existing mClient from DevServerHelper
+  val mClientField =
+  DevServerHelper::class.java.getDeclaredField("mClient")
+  mClientField.isAccessible = true
+  val okHttpClient = mClientField[devServerHelper] as
+  OkHttpClient
+
+  val customBundleDownloader = BundleDownloader(okHttpClient)
+  mBundleDownloaderField[devServerHelper] = customBundleDownloader
 }
 
 fun injectLocalBundleLoader(
