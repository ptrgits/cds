---
globs: packages/mobile-visualization/**/*.*
alwaysApply: false
---

# Mobile Visualization Guidelines

You are an expert in React Native, TypeScript, react-native-svg, react-native-reanimated, and mobile charting/visualization development.

## React Native SVG

### Import Patterns

Always import SVG components directly from `react-native-svg`, NOT from React:

```typescript
// ✅ Correct
import { G, Rect, Circle, Path, Line, Text } from 'react-native-svg';

// ❌ Wrong - Don't use React's SVGProps
import type { SVGProps } from 'react';
```

### Transform Format

React Native SVG requires transforms as an array of objects, not strings:

```typescript
// ✅ Correct - Array of transform objects
<G transform={[{ translateX: 100 }, { translateY: 50 }]} />
<G transform={[{ rotate: 45 }, { scale: 1.5 }]} />

// ❌ Wrong - String transforms don't work
<G transform="translate(100, 50)" />
<G transform={`rotate(${angle})`} />
```

### Animated Components

Create animated versions of SVG components:

```typescript
import Reanimated from 'react-native-reanimated';
import { G, Circle, Path } from 'react-native-svg';

const AnimatedG = Reanimated.createAnimatedComponent(G);
const AnimatedCircle = Reanimated.createAnimatedComponent(Circle);
const AnimatedPath = Reanimated.createAnimatedComponent(Path);
```

## React Native Reanimated

### Shared Values

Use shared values for animated properties:

```typescript
import { useSharedValue, withSpring, withTiming } from 'react-native-reanimated';

// Initialize shared values
const translateX = useSharedValue(0);
const translateY = useSharedValue(0);
const opacity = useSharedValue(1);

// Update with animations
translateX.value = withSpring(newX, { damping: 20, stiffness: 300 });
opacity.value = withTiming(0.5, { duration: 300 });
```

### Animated Props

Use `useAnimatedProps` for SVG properties:

```typescript
const animatedProps = useAnimatedProps(() => ({
  transform: [
    { translateX: translateX.value },
    { translateY: translateY.value },
  ],
  opacity: opacity.value,
}));

// Apply to component
<AnimatedG animatedProps={animatedProps}>
  {/* children */}
</AnimatedG>
```

### Important Rules

1. **Never access `.value` during render** - Only in effects or worklets
2. **Use worklets for performance** - Mark functions with `'worklet'`
3. **Run UI updates on UI thread** - Use `runOnJS` sparingly

```typescript
// ✅ Good - Update in effect
useEffect(() => {
  animatedX.value = targetX;
}, [targetX]);

// ❌ Bad - Reading during render
const x = animatedX.value; // Will cause warnings

// ✅ Good - Using runOnJS for callbacks
const onComplete = () => {
  'worklet';
  runOnJS(setStateVariable)(newValue);
};
```

## Animation Patterns

### Scrubber/Point Animation

For interactive elements like scrubbers:

```typescript
// 1. Track state (idle vs active)
const isIdleState = scrubberPosition === undefined;

// 2. Different behavior per state
useEffect(() => {
  if (!isIdleState) {
    // Immediate updates during interaction
    animatedX.value = targetX;
    animatedY.value = targetY;
  } else {
    // Smooth animations when idle
    animatedX.value = withSpring(targetX);
    animatedY.value = withSpring(targetY);
  }
}, [targetX, targetY, isIdleState]);

// 3. Conditional rendering for performance
if (!isIdleState) {
  // Render without animation wrapper for better performance
  return <G>{/* content */}</G>;
}
// Render with animation wrapper
return <AnimatedG animatedProps={animatedProps}>{/* content */}</AnimatedG>;
```

### Initial Animations

For fade-in or scale-in effects:

```typescript
const opacity = useSharedValue(0);

useEffect(() => {
  opacity.value = withDelay(
    850, // delay in ms
    withTiming(1, { duration: 150 }),
  );
}, []);
```

### Path Morphing

For animating path changes, use D3 with React Native SVG:

```typescript
import { interpolatePath } from 'd3-interpolate-path';
import { select } from 'd3-selection';

// Use refs and D3 for complex path animations
const pathRef = useRef<Path>(null);
select(pathRef.current)
  .transition()
  .duration(300)
  .attrTween('d', () => interpolatePath(oldPath, newPath));
```

## Performance Best Practices

### 1. Minimize Re-renders

- Use `memo` for components
- Split animated and static content
- Use `useMemo` for expensive calculations

```typescript
const targetPosition = useMemo(
  () => projectPoint({ x: dataX, y: dataY, xScale, yScale }),
  [dataX, dataY, xScale, yScale],
);
```

### 2. Efficient Updates

- Batch related animations
- Use shared values instead of state for animated properties
- Avoid creating new objects in render

```typescript
// ✅ Good - Stable reference
const springConfig = useMemo(() => ({ damping: 20, stiffness: 300 }), []);

// ❌ Bad - New object every render
withSpring(x, { damping: 20, stiffness: 300 });
```

### 3. Conditional Animation

- Only animate when necessary
- Provide non-animated fallbacks
- Check if animation is enabled

```typescript
if (animate && isIdleState) {
  animatedX.value = withSpring(targetX);
} else {
  animatedX.value = targetX; // Immediate update
}
```

## Coordinate Systems

### Data to Pixel Conversion

Always use scale functions to convert data coordinates to pixels:

```typescript
import { projectPoint } from '@coinbase/cds-common/visualizations/charts';

const pixelCoordinates = useMemo(
  () => projectPoint({ x: dataX, y: dataY, xScale, yScale }),
  [dataX, dataY, xScale, yScale],
);
```

### Transform Approach

For positioning elements, prefer transforms over absolute positioning:

```typescript
// ✅ Good - Render at origin, transform to position
<AnimatedG animatedProps={animatedProps}>
  <Circle cx={0} cy={0} r={4} />
</AnimatedG>

// Less optimal - Animating cx/cy directly
<AnimatedCircle cx={animatedX} cy={animatedY} r={4} />
```

## Common Pitfalls to Avoid

1. **String transforms** - Always use array format
2. **Reading `.value` in render** - Use in effects/worklets only
3. **Not initializing shared values** - Can cause flash at origin
4. **Forgetting platform differences** - Web uses CSS transforms, mobile uses objects
5. **Over-animating** - Not everything needs animation
6. **Missing memoization** - Recalculating on every render
7. **Using framer-motion** - NEVER use framer-motion in mobile packages. Use react-native-reanimated exclusively

## Testing Animations

When debugging animations:

1. Log state changes in effects, not renders
2. Check if shared values are updating
3. Verify transform format is correct
4. Test on actual devices (simulator behavior may differ)
5. Use React Native Reanimated's Chrome DevTools integration

## Cross-Platform Alignment

When porting from web to mobile:

- Web: `transform: "translate(x, y)"` → Mobile: `transform: [{ translateX: x }, { translateY: y }]`
- Web: `framer-motion` → Mobile: `react-native-reanimated`
- Web: CSS units (px, %) → Mobile: Numbers only
- Web: `motion.g` → Mobile: `AnimatedG`
- Web: `useAnimation()` → Mobile: `useSharedValue()` + `useAnimatedProps()`

# Mobile Visualization Guidelines

You are an expert in React Native, TypeScript, react-native-svg, react-native-reanimated, and mobile charting/visualization development.

## React Native SVG

### Import Patterns

Always import SVG components directly from `react-native-svg`, NOT from React:

```typescript
// ✅ Correct
import { G, Rect, Circle, Path, Line, Text } from 'react-native-svg';

// ❌ Wrong - Don't use React's SVGProps
import type { SVGProps } from 'react';
```

### Transform Format

React Native SVG requires transforms as an array of objects, not strings:

```typescript
// ✅ Correct - Array of transform objects
<G transform={[{ translateX: 100 }, { translateY: 50 }]} />
<G transform={[{ rotate: 45 }, { scale: 1.5 }]} />

// ❌ Wrong - String transforms don't work
<G transform="translate(100, 50)" />
<G transform={`rotate(${angle})`} />
```

### Animated Components

Create animated versions of SVG components:

```typescript
import Reanimated from 'react-native-reanimated';
import { G, Circle, Path } from 'react-native-svg';

const AnimatedG = Reanimated.createAnimatedComponent(G);
const AnimatedCircle = Reanimated.createAnimatedComponent(Circle);
const AnimatedPath = Reanimated.createAnimatedComponent(Path);
```

## React Native Reanimated

### Shared Values

Use shared values for animated properties:

```typescript
import { useSharedValue, withSpring, withTiming } from 'react-native-reanimated';

// Initialize shared values
const translateX = useSharedValue(0);
const translateY = useSharedValue(0);
const opacity = useSharedValue(1);

// Update with animations
translateX.value = withSpring(newX, { damping: 20, stiffness: 300 });
opacity.value = withTiming(0.5, { duration: 300 });
```

### Animated Props

Use `useAnimatedProps` for SVG properties:

```typescript
const animatedProps = useAnimatedProps(() => ({
  transform: [
    { translateX: translateX.value },
    { translateY: translateY.value },
  ],
  opacity: opacity.value,
}));

// Apply to component
<AnimatedG animatedProps={animatedProps}>
  {/* children */}
</AnimatedG>
```

### Important Rules

1. **Never access `.value` during render** - Only in effects or worklets
2. **Use worklets for performance** - Mark functions with `'worklet'`
3. **Run UI updates on UI thread** - Use `runOnJS` sparingly

```typescript
// ✅ Good - Update in effect
useEffect(() => {
  animatedX.value = targetX;
}, [targetX]);

// ❌ Bad - Reading during render
const x = animatedX.value; // Will cause warnings

// ✅ Good - Using runOnJS for callbacks
const onComplete = () => {
  'worklet';
  runOnJS(setStateVariable)(newValue);
};
```

## Animation Patterns

### Scrubber/Point Animation

For interactive elements like scrubbers:

```typescript
// 1. Track state (idle vs active)
const isIdleState = scrubberPosition === undefined;

// 2. Different behavior per state
useEffect(() => {
  if (!isIdleState) {
    // Immediate updates during interaction
    animatedX.value = targetX;
    animatedY.value = targetY;
  } else {
    // Smooth animations when idle
    animatedX.value = withSpring(targetX);
    animatedY.value = withSpring(targetY);
  }
}, [targetX, targetY, isIdleState]);

// 3. Conditional rendering for performance
if (!isIdleState) {
  // Render without animation wrapper for better performance
  return <G>{/* content */}</G>;
}
// Render with animation wrapper
return <AnimatedG animatedProps={animatedProps}>{/* content */}</AnimatedG>;
```

### Initial Animations

For fade-in or scale-in effects:

```typescript
const opacity = useSharedValue(0);

useEffect(() => {
  opacity.value = withDelay(
    850, // delay in ms
    withTiming(1, { duration: 150 }),
  );
}, []);
```

### Path Morphing

For animating path changes, use D3 with React Native SVG:

```typescript
import { interpolatePath } from 'd3-interpolate-path';
import { select } from 'd3-selection';

// Use refs and D3 for complex path animations
const pathRef = useRef<Path>(null);
select(pathRef.current)
  .transition()
  .duration(300)
  .attrTween('d', () => interpolatePath(oldPath, newPath));
```

## Performance Best Practices

### 1. Minimize Re-renders

- Use `memo` for components
- Split animated and static content
- Use `useMemo` for expensive calculations

```typescript
const targetPosition = useMemo(
  () => projectPoint({ x: dataX, y: dataY, xScale, yScale }),
  [dataX, dataY, xScale, yScale],
);
```

### 2. Efficient Updates

- Batch related animations
- Use shared values instead of state for animated properties
- Avoid creating new objects in render

```typescript
// ✅ Good - Stable reference
const springConfig = useMemo(() => ({ damping: 20, stiffness: 300 }), []);

// ❌ Bad - New object every render
withSpring(x, { damping: 20, stiffness: 300 });
```

### 3. Conditional Animation

- Only animate when necessary
- Provide non-animated fallbacks
- Check if animation is enabled

```typescript
if (animate && isIdleState) {
  animatedX.value = withSpring(targetX);
} else {
  animatedX.value = targetX; // Immediate update
}
```

## Coordinate Systems

### Data to Pixel Conversion

Always use scale functions to convert data coordinates to pixels:

```typescript
import { projectPoint } from '@coinbase/cds-common/visualizations/charts';

const pixelCoordinates = useMemo(
  () => projectPoint({ x: dataX, y: dataY, xScale, yScale }),
  [dataX, dataY, xScale, yScale],
);
```

### Transform Approach

For positioning elements, prefer transforms over absolute positioning:

```typescript
// ✅ Good - Render at origin, transform to position
<AnimatedG animatedProps={animatedProps}>
  <Circle cx={0} cy={0} r={4} />
</AnimatedG>

// Less optimal - Animating cx/cy directly
<AnimatedCircle cx={animatedX} cy={animatedY} r={4} />
```

## Common Pitfalls to Avoid

1. **String transforms** - Always use array format
2. **Reading `.value` in render** - Use in effects/worklets only
3. **Not initializing shared values** - Can cause flash at origin
4. **Forgetting platform differences** - Web uses CSS transforms, mobile uses objects
5. **Over-animating** - Not everything needs animation
6. **Missing memoization** - Recalculating on every render
7. **Using framer-motion** - NEVER use framer-motion in mobile packages. Use react-native-reanimated exclusively

## Testing Animations

When debugging animations:

1. Log state changes in effects, not renders
2. Check if shared values are updating
3. Verify transform format is correct
4. Test on actual devices (simulator behavior may differ)
5. Use React Native Reanimated's Chrome DevTools integration

## Cross-Platform Alignment

When porting from web to mobile:

- Web: `transform: "translate(x, y)"` → Mobile: `transform: [{ translateX: x }, { translateY: y }]`
- Web: `framer-motion` → Mobile: `react-native-reanimated`
- Web: CSS units (px, %) → Mobile: Numbers only
- Web: `motion.g` → Mobile: `AnimatedG`
- Web: `useAnimation()` → Mobile: `useSharedValue()` + `useAnimatedProps()`
